// @flow
/*
 * Function returns subgroups of group as array of BitSets
 */

import * as MathUtils from './MathUtils.js';
import BasicGroup from './BasicGroup.js';
import BitSet from './BitSet.js';
import Subgroup from './Subgroup.js';

export default
class SubgroupFinder {
/*::
   group: BasicGroup;
   z_generators: BitSet;
 */
   constructor (group /*: BasicGroup */) {
      this.group = group;
      this.z_generators = new BitSet(group.order);
      for (let i = 1; i < group.order; i++) {
         if (MathUtils.isPrimePower(group.elementOrders[i])) {
            this.z_generators.set(i);
         }
      }
   }

   static getSubgroups(group /*: BasicGroup */) /*: [Array<Subgroup>, boolean] */ {
      let allSubgroups,
          isSolvable = true,
          subGroupFinder = new SubgroupFinder(group);

      // special case cyclic groups, trivial group
      if (group.order == 1) {
         allSubgroups = [ new Subgroup(group, [0], [0]) ];
      } else if (MathUtils.isPrime(group.order)) {
         allSubgroups = [
            new Subgroup(group, [0], [0]),
            new Subgroup(group, [1]).setAllMembers(),
         ];
      } else {
         allSubgroups = subGroupFinder.findAllSubgroups();
      }

      allSubgroups.sort((a,b) => a.members.popcount() - b.members.popcount());
      const last_subgroup_found = allSubgroups[allSubgroups.length - 1];
      if (last_subgroup_found.members.popcount() != group.order) {
         isSolvable = false;
         // take generators from the next-smallest subgroup, add an element not in that group, and minimize generators
         const new_subgroup = new Subgroup(group, last_subgroup_found.generators.toArray()).setAllMembers();
         const new_element =
               ((BitSet.difference(new_subgroup.members, last_subgroup_found.members).first() /*: any */) /*: groupElement */);
         subGroupFinder.minimizeGenerators(new_subgroup, new_element);
         allSubgroups.push(new_subgroup);
      }

      SubgroupFinder.addSubgroupLattice(allSubgroups);

      return [allSubgroups, isSolvable];
   }

   // Add subgroup containment lattice to subgroups
   // contains/containedIn are fields in the Sugroup object
   // of BitSets of indexes into the group.subgroups array
   // indicating subgroups immediately contained by/containing this subgroup
   static addSubgroupLattice(subgroups /*: Array<Subgroup> */) {
      const numSubgroups = subgroups.length;

      // initialize contains, containedIn fields
      subgroups.forEach( (h) => {
         h.contains = new BitSet(numSubgroups);
         h.containedIn = new BitSet(numSubgroups);
      } )

      // Set fields to indirect as well as direct containment
      // Note the starting index of the inner loop: subgroups are ordered by increasing size,
      //   and containers are bigger than containees
      for (let containeeIndex = 0; containeeIndex < numSubgroups; containeeIndex++) {
         const containee = subgroups[containeeIndex];
         for (let containerIndex = containeeIndex + 1; containerIndex < numSubgroups; containerIndex++) {
            const container = subgroups[containerIndex];
            if (container.members.contains(containee.members)) {
               container.contains.set(containeeIndex);
               containee.containedIn.set(containerIndex);
            }
         }
      }

      // Clear indirect containment
      for (let containeeIndex = 0; containeeIndex < numSubgroups; containeeIndex++) {
         const containee = subgroups[containeeIndex];
         for (let containerIndex = containeeIndex + 1; containerIndex < numSubgroups; containerIndex++) {
            const container = subgroups[containerIndex];
            if (container.contains.isSet(containeeIndex)) {
               container.contains.subtract(containee.contains);
            }
         }
      }
   }


   findAllSubgroups() /*: Array<Subgroup> */ {
      const subgroups = [];

      let currLayer = [new Subgroup(this.group, [0], [0])];  // 0-th layer is trivial group
      for (;;) {
         let nextLayer = this.findNextLayer(currLayer);
         subgroups.push(...currLayer);
         if (nextLayer.length == 0) {
            break;
         }
         currLayer = nextLayer;
      }

      return subgroups;
   }

   /*
      Cyclic extension algorithm from
      "Fundamental Algorithms for Permutation Groups" by Greg Butler (1991)
    */
   findNextLayer(currLayer /*: Array<Subgroup> */) /*: Array<Subgroup> */ {
      const nextLayer = [];

      for (let i = 0; i < currLayer.length; i++) {
         const currSubgroup = currLayer[i];
         const normalizer = this.findNormalizer(currSubgroup);
         const todo = BitSet.intersection(
            this.z_generators,
            BitSet.difference(normalizer.members, currSubgroup.members));
         for (let j = 0; j < nextLayer.length; j++) {
            const nextSubgroup /*: Subgroup */ = nextLayer[j];
            if (nextSubgroup.members.contains(currSubgroup.members)) {
               todo.subtract(nextSubgroup.members);
            }
         }

         for (let g = todo.pop(); g != undefined; g = todo.pop()) {
            if (! BitSet.intersection(this.group.elementPrimePowers[g],
                                      currSubgroup.members)
                        .isEmpty()) {
               let nextSubgroup = currSubgroup.clone();
               this.extendSubgroup(nextSubgroup, g);
               this.minimizeGenerators(nextSubgroup, g);
               nextLayer.push(nextSubgroup);
               todo.subtract(nextSubgroup.members);
            }
         }
      }

      return nextLayer;
   }

   /*
      Input: group G, subgroup U

      Output: normalizer H of U in G

      H = U
      gamma = G - H
      while gamma is not empty
      choose a g from gamma
      if g normalizes H then
      H = < H, g >
      gamma = gamma - H
      else
      gamma = gamma - (H x g)
      end if
      end while
    */
   findNormalizer(subgroup /*: Subgroup */) /*: Subgroup */ {
      let normalizer = subgroup.clone(),
          todo = new BitSet(this.group.order).setAll().subtract(subgroup.members);

      for (let g = todo.pop(); g != undefined; g = todo.pop()) {
         if (this.normalizes(subgroup, g)) {
            this.extendSubgroup(normalizer, g);
            todo.subtract(normalizer.members);
         } else {
            for (let i = 0; i < this.group.order; i++) {
               if (normalizer.members.isSet(i)) {
                  todo.clear(this.group.multtable[i][g]);
               }
            }
         }
      }

      return normalizer;
   }

   normalizes(subgroup /*: Subgroup */, g /*: number */) /*: boolean */{
      const mult = (a,b) => this.group.multtable[a][b];
      const g_inverse = this.group.inverses[g];
      for (let i = 0; i < this.group.order; i++) {
         if (subgroup.generators.isSet(i)) {
            if (! subgroup.members.isSet(mult(mult(g, i), g_inverse))) {
               return false;
            }
         }
      }
      return true;
   }

   extendSubgroup(subgroup /*: Subgroup */, normalizer /*: number */) {
      const todo = this.group.elementPowers[normalizer];
      for (let i = 0; i < subgroup.members.len; i++) {
         if (subgroup.members.isSet(i)) {
            for (let j = 0; j < todo.len; j++) {
               if (todo.isSet(j)) {
                  subgroup.members.set(this.group.multtable[i][j]);
               }
            }
         }
      }
   }

   minimizeGenerators(subgroup /*: Subgroup */, extension /*: number */) {
      // 1) find an element that will generate what extension and an existing generator do now
      const generators = subgroup.generators.toArray();
      for (let i = 0; i < generators.length; i++) {
         const closure = this.group.closure([extension, generators[i]]);
         const order_classes = this.group.orderClasses[closure.popcount()];
         if (order_classes !== undefined) {
            const cyclic_generator =
               order_classes.toArray().find( (element) => this.group.elementPowers[element].equals(closure) );
            if (cyclic_generator !== undefined) {
               subgroup.generators
                       .clear(generators[i])
                       .set(cyclic_generator);
               return;
            }
         }
      }

      // 2) see if we can't remove one of the existing generators and still get the entire subgroup
      generators.push(extension);
      for (let i = 0; i < generators.length - 1; i++) {
         const gens = generators.slice();
         gens.splice(i,1);
         const closure = this.group.closure(gens);
         if (closure.equals(subgroup.members)) {
            subgroup.generators
                    .clear(generators[i])
                    .set(extension);
            return;
         }
      }

      subgroup.generators.set(extension);
      return;
   }
}
